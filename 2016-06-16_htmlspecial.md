# HTML Special

## 2016-06-16, Амстердам, Нидерланды

Доброе утро! Сегодня с вами снова [@pepelsbey](https://twitter.com/pepelsbey "Вадим Макеев") с конференции HTML Special в Амстердаме. Поговорим про HTML, разогрев перед завтрашней CSS Day.

Начнём уже полчаса, а пока публика завтракает круассанами, чего и вам желаю :3

[pic.twitter.com/0rVd1bhHm0](https://t.co/0rVd1bhHm0)

![](https://pbs.twimg.com/media/ClDXOROVAAAR55U.jpg)

Расписание HTML Specal: [cssday.nl/2016/programme](https://t.co/OguC7vNMhc "http://cssday.nl/2016/programme") — 8 нетривиальных докладов про 8 HTML-элементов от Джереми Кита, Лии Веру, Йова Вайса и др.

Скоро начнём [pic.twitter.com/fMMYizAP93](https://t.co/fMMYizAP93)

![](https://pbs.twimg.com/media/ClDdpDdUgAE2CAE.jpg)

На сцене ведущий, открываем: 4-й CSS Day и 1-й HTML Special. Целый день про HTML, представляете? Спонсоры Microsoft и MailChimp.

Открывает HTML Special Джереми Кит с докладом про элемент &lt;a&gt;. Тот самый.

A — Апофения, переживание, заключающееся в способности видеть взаимосвязи в случайных данных [ru.wikipedia.org/wiki/Апофения](https://t.co/Uy5g1Wp5F8 "https://ru.wikipedia.org/wiki/Апофения")

Первая ссылка интернета [pic.twitter.com/16vnjLZOzq](https://t.co/16vnjLZOzq)

![](https://pbs.twimg.com/media/ClDfFAHUYAQJKkp.jpg)

Вместо name мы теперь используем id, но это не слишком частый случай. А вот href взлетел и сделал интернет, каким мы его знаем.

А — Архив. Старинный доклад про библиотеки будущего, удивительно напоминает современный интернет.

Рассказ Борхеса «Вавилонская библиотека» перекликается с идеей современного интернета [ru.wikipedia.org/wiki/Вавилонск…](https://t.co/PtCF3xsR3w "https://ru.wikipedia.org/wiki/Вавилонская_библиотека")

Джереми пытается пытается подсчитать количество книг в библиотеке Вавилона, но их больше, чем атомов во Вселенной [pic.twitter.com/ZAKxxJtlAb](https://t.co/ZAKxxJtlAb)

![](https://pbs.twimg.com/media/ClDgSo3UsAArD_A.jpg)

Онлайн-версия библиотеки Вавилона со \(всеми?\) текстами интернета [libraryofbabel.info](https://t.co/9AqbEaqo6L "https://libraryofbabel.info/")

Эссе Бохеса «The Analytical Language of John Wilkins», классификация информации на основе звуков — [en.wikipedia.org/wiki/The\_Analy…](https://t.co/Cx7fsWKyux "https://en.wikipedia.org/wiki/The_Analytical_Language_of_John_Wilkins")

A — Ada Lovelace, [en.wikipedia.org/wiki/Ada\_Lovel…](https://t.co/ywIO64z3jd "https://en.wikipedia.org/wiki/Ada_Lovelace") [pic.twitter.com/R4pS5S2L5K](https://t.co/R4pS5S2L5K)

![](https://pbs.twimg.com/media/ClDhPYvUgAAX2ea.jpg)

A — ARPANET, [ru.wikipedia.org/wiki/ARPANET](https://t.co/SHZRcgYyJQ "https://ru.wikipedia.org/wiki/ARPANET") После первого сообщения «log in» отправленного по прототипу интернета в 1969 году, он лёг.

Из ARPANET вышел TCP/IP и до сих пор является основой всех сетевых протоколов — [ru.wikipedia.org/wiki/TCP/IP](https://t.co/Y7oErhJuhc "https://ru.wikipedia.org/wiki/TCP/IP")

[pic.twitter.com/mVeWfC5Co3](https://t.co/mVeWfC5Co3)

![](https://pbs.twimg.com/media/ClDjf7gUoAAbbcp.jpg)

Первый человек с телефоном был самым грустным человеком в истории. Ему некому было позвонить \(

Логотип интернета [pic.twitter.com/oGrCiGUVeW](https://t.co/oGrCiGUVeW)

![](https://pbs.twimg.com/media/ClDkhPUUkAApt8d.jpg)

XFN, XHTML Friends Network, старая идея отношений между страницами \(сайтами\) на основе атрибута rel="…" у ссылки.

A — Adactio, сайт Джереми [adactio.com](https://t.co/neZ2Ip7P78 "https://adactio.com/")  
  
&lt;a href="…" rel="me"&gt;Твиттер, rel="me" значит «мой Твиттер».

Значение rel="nofollow" не имеет вообще никакого смысла \(отношение «не ходи»? чушь\), но не будем спорить с полутонной гориллой Гугл.

IndieWebCamp, собрание людей, противостоящих корпоративному вебу. Создавайте личные сайты, но у кого есть время? [indiewebcamp.com](https://t.co/kdom2OqGlA "https://indiewebcamp.com/")

Огороженные пространства — как безопасны, так и скучны. Фейсбук, Инстаграм…

Другой рассказ Борхеса — [ru.wikipedia.org/wiki/Сад\_расхо…](https://t.co/wnuoqiw49Z "https://ru.wikipedia.org/wiki/Сад_расходящихся_тропок") Заблудитесь в интернете, идите по своим тропинкам.

У интернета нет центра. Каждый путь главный, каждый &lt;a&gt; может стать порталом в целую вселенную знаний.

— Будет ли книга про историю интернета, Джереми?  
— Я случайно написал что-то похожее и думаю самостоятельно издать, с веб-версией, конечно.

Централизация — большая проблема интернета. Теряется один источник и сразу теряются множество связей.

Второй доклад на HTML Special: Йоав Вайс про элемент &lt;link&gt;. Называет себя «performance freak», работает на  Akamai.

[pic.twitter.com/LJy4aMCDSS](https://t.co/LJy4aMCDSS)

![](https://pbs.twimg.com/media/ClDp1bMVEAAGbG-.jpg)

&lt;link&gt; определяет отношения между страницей и его ресурсами. Младший брат &lt;a&gt; с самой первой версии HTML, но работает иначе, самостоятельно.

[pic.twitter.com/GQoIZq1x50](https://t.co/GQoIZq1x50)

![](https://pbs.twimg.com/media/ClDqUbJUkAEp2op.jpg)

Типы определяются атрибутом rel и многие из первых значений давно не используются, но есть много новых [w3.org/TR/html5/links…](https://t.co/S71ELcqL1w "https://www.w3.org/TR/html5/links.html#linkTypes")

Была идея &lt;style src="style.css"&gt;, но выжил &lt;link rel="stylesheet"&gt; из-за другой модели относительных путей.

Чтобы получить значения &lt;link rel&gt; есть токен-лист relList, у каждого токена есть метод supports\(\), проверяющий умеет ли браузер.

Атрибут media помогает браузеру решить: подгружать ресурс или нет, в зависимости от медиатипа.

Когда-то только Opera на Presto вела себя 100% правильно, из-за этого ломались многие страницы, пришлось сломать поведение для совместимости

Сейчас Chrome не подргружает &lt;link rel="stylesheet" type="foo/bar"&gt; с неизвестным типом, а WebKit всё ещё подгружает.

Один из самых сложных атрибутов crossorigin, но это тема для отдельного доклада.

HTTP-заголовок Link, приходящий со страницей, может заменить теги &lt;link&gt;, иногда это очень удобно.

Загрузка страницы — это очень, очень сложно. Множество ресурсов, сложная система приоритетов и нужно справиться в короткое время.

Давным-давно страницы загружались так: каждый элемент решал что и когда ему загружать. Всё было просто, но был &lt;script&gt;, он мог всё менять.

[pic.twitter.com/hshc3yRUKO](https://t.co/hshc3yRUKO)

![](https://pbs.twimg.com/media/ClDt9qhVYAEUixP.jpg)

Где-то в 2008 году браузеры начали менять поведение, чтобы обойти проблему блокировки рендеринга скриптами.

Браузеры отделили загрузку ресурсов от построения DOM. Браузеры начали делать предзагрузку после нахождения ресурсов, пока строится дерево.

Механизмы предзагрузки — не спецификация, каждый браузер делает это по-своему, даже называет это по-своему.

Крёстный отец быстродействия Стив Саудерс назвал это самым важным из созданных механизмов ускорениея страниц.

Дерево зависимостей ресурсов и приоритетов среднего сайта невозможно представить, схема очень сложная.

Как помочь браузерам понять и действовать эффективно? Не загружать и не вставлять через JS, иметь всё в HTML.

Есть и другие подсказки, которые долгое время были нестандартными и по-разному внедрены в большинстве браузеров.

&lt;link rel="dns-prefetch"&gt;, &lt;link rel="preconnect"&gt; \(нужно знать crossorigin и протокол\) — запрос к нужному ресурсу, чтобы прогреть сеть.

То есть &lt;link rel="preconnect crossorigin"&gt;

&lt;link rel="prefetch"&gt; подсказывает браузеру следующий шаг. Загрузка продолжается в фоне, если даже пользователь уже пошёл дальше.

&lt;link rel="next"&gt; подсказывает, что эта будущая страница, загрузи её и рендери. &lt;link rel="prerender"&gt; похож, но говорит не о следующей стр.

Мобильные браузеры сейчас игнорируют next и prerender, чтобы сэкономить память, процессор и, в итоге, батарею.

Но самый любимый rel Йоава \(только не говорите другим релам\) — это &lt;link rel="preload" as="…"&gt; и атрибут.

Атрибут as говорит о типе ресурса, а браузер уже применяет к нему свои приоритеты. Стили важнее картинок, например.

Атрибут rel=preload помогает браузеру загружать ресурсы максимально совместимо, эффективно и безопасно.

Например, &lt;link rel="preload" src="script.js" as="script"&gt; подсказывает подгрузку скрипта со скриптовым приоритетом.

Очень хороший пример — ранняя подгрузка шрифтов, as=font

[pic.twitter.com/pfNFxSEImA](https://t.co/pfNFxSEImA)

![](https://pbs.twimg.com/media/ClDyhG5VEAAI2Tk.jpg)

Атрибут crossorigin должен быть, всегда, даже если кажется, что ненужно. Йоав пытался это побороть, но не вышло.

Другой пример: отделить загрузку скрипта от его исполнения. Загрузка через XHR, потом eval — очен хрупко и плохо.

Как делать это правильно [pic.twitter.com/8ZTE94huT1](https://t.co/8ZTE94huT1)

![](https://pbs.twimg.com/media/ClDzCq9UoAA_T5Y.jpg)

Если такое же предзагрузить через XHR, то браузер загрузит скрип дважды. Не делайте так.

Стили без блокировки рендеринга, отличный трюк [pic.twitter.com/kack2BtEs3](https://t.co/kack2BtEs3)

![](https://pbs.twimg.com/media/ClDzUYfUsAArbqb.jpg)

Отличный способ загрузки стилей, нужных за пределами начального вьюпорта. Можно делать такое на JS, но это значительно сложнее.

Можно применять и медиавыражения: подгрузи, если сматчился [pic.twitter.com/DUD6mwPcuu](https://t.co/DUD6mwPcuu)

![](https://pbs.twimg.com/media/ClDz2CPVEAAZOl_.jpg)

Проверка поддержки preload, Йоав работает над реализацией этого для Chrome и WebKit [pic.twitter.com/b9b8vewPNd](https://t.co/b9b8vewPNd)

![](https://pbs.twimg.com/media/ClD0EujUYAAh02l.jpg)

Ещё есть пуш для HTTP/2, в чём-то повторяющий то, что делает rel=preload. Пуш H2 отправляет ресурсы браузеру заранее, мол, подгружай давай.

Есть специальный декларативный &lt;link rel="serviceworker"&gt; для включения сервис-воркеров.

Что мы узнали сегодня:  
— link — круто  
— загрузка ресурсов — сложно  
— помогайте \(не мешайте\) браузерам

— Будет ли Subresource Integrity для &lt;link&gt;?  
— Да, надо бы, очень полезная штука, пока нет, но есть для скриптов  
  
[w3.org/TR/SRI/](https://t.co/SoJsLlggmX "https://www.w3.org/TR/SRI/")

У нас перерыв до 12:10 по Москве, продолжим с докладом про элемент &lt;layer&gt;, кто-нибудь вообще помнит про такой?

Перерыв подходит к концу [pic.twitter.com/3A7T6HDEYR](https://t.co/3A7T6HDEYR)

![](https://pbs.twimg.com/media/ClD6sDmWkAAKwx5.jpg)

Третий доклад на HTML Special: Питер-Пол Кох про элемент &lt;layer&gt;.

— Кто работал с &lt;layer&gt;?  
— \(пять рук в зале\)  
— Вот вы помните, что такое настоящие кроссбраузерные проблемы, объясните младшим соседям

Если вы помните про Netscape 4 и &lt;layer&gt;, значит вы помните важные уроки, которые дала нам история.

Итак, история. Браузерные войны — попытка Netscape и Microsoft сделать \_специально\_ несовместимые браузеры, чтобы получить пользователей.

Вы должны использовать Netscape 4.0 или Internet Explorer 4.0, чтобы открыть этот сайт. И родилась привычка тестировать в одном браузере.

[pic.twitter.com/r3Z1mJQ9jJ](https://t.co/r3Z1mJQ9jJ)

![](https://pbs.twimg.com/media/ClD9HjaWMAAtnO1.jpg)

IE выиграл войну браузеров потому, что был лучшим браузером. IE6 в момент выхода был лучшим в мире браузером, настоящим прорывом.

Инструменты, первая волна. Чтобы справиться с разницей в браузерах, нужны были инструменты. Помните Dynamic Drive? Вряд ли.

И мы начали компенсировать комплекс «я не настоящий программист, я только HTML пишу» [pic.twitter.com/YHar1Sll95](https://t.co/YHar1Sll95)

![](https://pbs.twimg.com/media/ClD-FeSWIAAXQwB.jpg)

Революция веб-стандартов поменяла поле битвы, важную роль сыграл WaSP — [webstandards.org](https://t.co/Yv1RnOsZWh "http://www.webstandards.org/")

Революция стандартов началась с того, что разработчики начали создавать и упорядочивать собственную экосистему.

[pic.twitter.com/5Ed710nQ5a](https://t.co/5Ed710nQ5a)

![](https://pbs.twimg.com/media/ClD-o8AWEAAhIeN.jpg)

В нашей отрасли конференции и обмен знаниями очень сильно отличается от средней софтверной конференции.

Замкнулись в своей экосистеме и начали изобретать свой язык, как тинейджеры:  
  
— Псевдокласс — это псевдоэлемент, дурак что ли!

Софтверная революция [pic.twitter.com/EuF5amFIiW](https://t.co/EuF5amFIiW)

![](https://pbs.twimg.com/media/ClD_YcHXIAAXwQN.jpg)

Веб справился с софтверной революцией, например Google Docs, браузер стал основной программой.

Следующая революция — приложений. И мы почему-то начали имитировать нативные приложения и сравнивать браузеры с небраузерами.

Браузеры никогда не будут такими же хорошими, как нативные приложения. И это нормально, от этого не уйти. Браузер лежит между вебом и ОС.

Поэтому веб-приложения \_всегда\_ будут медленнее. Из-за прослойки браузера. Многие забывают об этом.

Мобильная революция: iPhone, iPhone, iPhone, iPhone, iPhone, iPhone, iPhone, iPhone, iPhone, iPhone, iPhone  
  
 iPhone. Другие телефоны? Не-а.

UC, BlackBerry, Samsung Chromium, Opera Mini — массовые браузеры с огромной долей. Кто-нибудь в них тестирует? Единицы в зале.

Кое-что немного поменялось, мы теперь тестируем в двух мобильных браузерах: Safari и Chrome.

Отзывчивый дизайн работает, благодаря своей простой модели: добавьте вьюпорт и всё, дальше резина и адаптация.

Если бы отзывчивый дизайн был сложнее, он бы стал так же непопулярен, как и прогрессивное улучшение. Хорошо бы, но, гм, эм, нет времени.

Революция инструментов — следующая. Каждую неделю новый фремворк, даже солидные гиганты, вроде Angular, React, Ember — новички.

[pic.twitter.com/6oRa1XvSli](https://t.co/6oRa1XvSli)

![](https://pbs.twimg.com/media/ClEBvKcWIAA5OZ_.jpg)

Всё это опять похоже на компенсацию. Веб-разработка — это же Серьёзная Штука™, не хухры-мухры. И куча инструментов со сложными конфигами.

Модуляризация провоцирует усложнение.

Правильный JS-разработчик [pic.twitter.com/eWGuWAxkL8](https://t.co/eWGuWAxkL8)

![](https://pbs.twimg.com/media/ClECi6kWgAAwl-U.jpg)

Попробуйте в каком-нибудь сайд-проекте хоть иногда не использовать фреймворки. Это многому вас научит.

Если вы используете JS-фреймворк, вы должны уметь изменить его под себя. То есть нужно понимать, как он работает.

Если вы не можете разрабатывать без инструментов, вы не настоящий веб-разработчик.

[pic.twitter.com/JWXMGzpLzr](https://t.co/JWXMGzpLzr)

![](https://pbs.twimg.com/media/ClEDMovWMAAgbhc.jpg)

Мы часто идём за советом в другие отрасли, к другим программистам \(хорошо\), которые не понимают сути веба и могут давать не те советы.

Веб — это не платформа. Веб — это платформы. Множество разных и под каждую мы разрабатываем.

И на множестве платформ вы никогда не сможете протестировать свой код. Смиритесь, поймите.

К вам приходят и вечнозелёный Chrome на последнем макбуке и устаревший UC на ржавой мобилке. И сайт должен работать.

Бэкендеры и другие привыкли к контролируемым условиям, с конечным списком платформ и требований. И применяют эти знания к фронтенду. Зря.

[pic.twitter.com/dcptlxTWSk](https://t.co/dcptlxTWSk)

![](https://pbs.twimg.com/media/ClEEScWWkAEtsuT.jpg)

Нет ООП в JS? Глупый, глупый язык! Ничего, имитируем. CSS? О, господи, наймите кого-нибудь для этого.

DRY? Don’t Repeat Yourself. Веб всё поменял: Do Repeat Yourself! Это фундаментально для веба.

Подгружаете что-то скриптом? Сделайте фолбек на ссылку в HTML, это фундаментальная особенность веба, он так работает и в этом его сила.

[pic.twitter.com/yuOnWqOdP3](https://t.co/yuOnWqOdP3)

![](https://pbs.twimg.com/media/ClEFCC3WIAIO_YW.jpg)

Вопросы [pic.twitter.com/j8X6Yeqoxe](https://t.co/j8X6Yeqoxe)

![](https://pbs.twimg.com/media/ClEF9HNXIAAV2tk.jpg)

Четвёртый доклад на HTML Special: Саймон Питерс про элемент &lt;source&gt;. Из Opera, автор множества спецификаций.

Элемент &lt;source&gt; не один, их скорее два. Один для &lt;video&gt;, другой для &lt;picture&gt;, но об этом позже.

Opera предложила элемент &lt;video&gt; в 2007 году [pic.twitter.com/byNvzBKmhn](https://t.co/byNvzBKmhn)

![](https://pbs.twimg.com/media/ClEHLevXEAAper_.jpg)

И тут появился &lt;source&gt; для разных кодеков [pic.twitter.com/swPmCWsYdP](https://t.co/swPmCWsYdP)

![](https://pbs.twimg.com/media/ClEHbGfWkAAbsE0.jpg)

Брюс Лоусон предложил элемент &lt;picture&gt; и идею использовать &lt;source&gt; [pic.twitter.com/vIWs6d7WB0](https://t.co/vIWs6d7WB0)

![](https://pbs.twimg.com/media/ClEHoTKWkAAEu9G.jpg)

Появился похожий srcset и image-set [pic.twitter.com/ZiZ5WfHzbX](https://t.co/ZiZ5WfHzbX)

![](https://pbs.twimg.com/media/ClEH18mXEAAW9Xz.jpg)

Почти 2 года предлагали разные решения для адаптивных картинок, даже предлагали атрибуты src-N и выбрать было сложно, куча нюансов.

Саймон предложил вариант с &lt;img&gt; как основой для &lt;picture&gt; [pic.twitter.com/cQfnpSEMrF](https://t.co/cQfnpSEMrF)

![](https://pbs.twimg.com/media/ClEIk-1WEAAPw7a.jpg)

Начнём с &lt;source&gt; для видео. Браузер идёт по каждому источнику и ищет подходящий, перебирая параметры: сеть, формат.

Ни один браузер до сих пор не проходит тесты, написанные к спецификации, всё очень сложно.

Внутри &lt;picture&gt; по-другому, браузер смотрит только на разметку, не на формат или сеть. Алгоритм выбора не продолжается, если картинки нет.

Элемент &lt;picture&gt; был разработан адаптивным и умеет показывать разные картинки в разных условиях.

Мутации DOM в случае с &lt;video&gt;, нужно применять изменения [pic.twitter.com/mecbwKYhWW](https://t.co/mecbwKYhWW)

![](https://pbs.twimg.com/media/ClEJ9qaWIAAefgA.jpg)

&lt;picture&gt; просто контейнер, всё показывает &lt;img&gt; [pic.twitter.com/W5d0AwibD1](https://t.co/W5d0AwibD1)

![](https://pbs.twimg.com/media/ClEKICiWgAAKWxY.jpg)

Атрибут media не работает для &lt;source&gt; внутри &lt;video&gt;, для этого нужно использовать JS, чтобы адаптировать к фулскрину, например.

Кадрирование в &lt;picture&gt; [pic.twitter.com/nVaNYMzlm5](https://t.co/nVaNYMzlm5)

![](https://pbs.twimg.com/media/ClEKmZBXIAAkkpU.jpg)

Атрибут srcset можно использовать для &lt;source&gt; только внутри &lt;picture&gt;.

Типичный случай для srcset — ретина [pic.twitter.com/arZkFmIoeo](https://t.co/arZkFmIoeo)

![](https://pbs.twimg.com/media/ClEK2QMWgAAe9sG.jpg)

Порядок внутри srcset неважен, важны управляющие конструкции.

Парсер srcset очень сложный, т.к. там есть запятые, а ссылки тоже могут содержать запятые.

Упомянутый ранее Йоавом preload scanner [pic.twitter.com/lzFWDu6YDX](https://t.co/lzFWDu6YDX)

![](https://pbs.twimg.com/media/ClELoW2XIAAtBiY.jpg)

Атрибут sizes подсказывает браузеру как рендерить картинку, иначе приходилось бы ждать загрузки, чтобы узнать её размеры.

Предполагается, что значения медиа совпадают с такими же в CSS [pic.twitter.com/WtmtXJ5yFc](https://t.co/WtmtXJ5yFc)

![](https://pbs.twimg.com/media/ClEMbpcWYAAy8l_.jpg)

Всё не так просто: в зависимости от раскладки картинка может быть больше на меньшем устройстве.

Синтаксис sizes [pic.twitter.com/YQ5xmXZda0](https://t.co/YQ5xmXZda0)

![](https://pbs.twimg.com/media/ClEM8xiWIAAWCjh.jpg)

Из-за того, что sizes использует CSS-синтаксис, там происходят очень странные и непривычные вещи: пропуск незнакомых блоков, экранирование.

Атрибут type довольно простой, работает одинаково для &lt;video&gt; и &lt;picture&gt;.

Сегодня благодаря &lt;picture&gt; и атрибуту type можно легко внедрять новые форматы графики, что невозможно было раньше.

А в таком случае когда начинается загрузка? [pic.twitter.com/2Ob1rOBg9I](https://t.co/2Ob1rOBg9I)

![](https://pbs.twimg.com/media/ClEOAceXIAIVHL0.jpg)

Есть т.н. микрозадачи, завершение которых браузер должен дожидаться и не загружать картинку дважды.

Предзагрузчик картинок должен знать про вьюпорт страницы, чтобы применять медиавыражения.

Ошибка в IE9 и как с ней справится [pic.twitter.com/K9cktdl5rO](https://t.co/K9cktdl5rO)

![](https://pbs.twimg.com/media/ClEO12yXEAAr0x6.jpg)

Атрибут sizes пока не поддерживает высоту, только ширину. Но есть один грязный трюк…

[pic.twitter.com/gKsT9zRTKy](https://t.co/gKsT9zRTKy)

![](https://pbs.twimg.com/media/ClEPMKxWkAAkvRF.jpg)

Что будет дальше с &lt;source&gt; и компанией?

[pic.twitter.com/GhmqLeB6zb](https://t.co/GhmqLeB6zb)

![](https://pbs.twimg.com/media/ClEPhVHWMAAJm7I.jpg)

Вопросы [pic.twitter.com/3IkWDIYPFk](https://t.co/3IkWDIYPFk)

![](https://pbs.twimg.com/media/ClEP2EqWQAAP6ia.jpg)

— Есть ли решения лучше, чем &lt;picture&gt;?  
— Новый формат FLIF для прогрессивной загрузки, но &lt;picture&gt; надолго.  
  
[flif.info](https://t.co/pEE08NqVhC "http://flif.info/")

— Как именно должно работать автоматическое определение sizes?  
— Вы можете описать размеры в CSS и браузер должен уметь догадываться об этом

Атрибут sizes конечно идёт вразрез с идеей разделения оформления и содержимого, но это необходимое зло для быстродействия.

У нас перерыв на ланч до 14:50 по Москве, вернёмся с докладом про &lt;noscript&gt;.

Кормят здесь неплохо [pic.twitter.com/5aTqVMVRPV](https://t.co/5aTqVMVRPV)

![](https://pbs.twimg.com/media/ClETfxgWgAAtCjK.jpg)

Пятый доклад на HTML Special: Нильс Линхер про элемент &lt;noscript&gt;.

[pic.twitter.com/z5rWPf1Y40](https://t.co/z5rWPf1Y40)

![](https://pbs.twimg.com/media/ClEggVaXEAAYsFM.jpg)

Легко ли сделать доклад на 45 минут про элемент, который ничего не делает? Но доклад приняли, пришлось что-то делать.

Но попался под руку Виталий Фридман и стал задавать странные вопросы: можно вложить &lt;noscript&gt; в &lt;noscript&gt;? Можно оформить? А если, а вдруг

Уникальность HTML в его совместимости: обратной и прямой, с будущими технологиями.

Первая страница всё ещё в интернете и любой браузер может его открыть, прекрасно же! [info.cern.ch/hypertext/WWW/…](https://t.co/XTby6rC83g "http://info.cern.ch/hypertext/WWW/TheProject.html")

И никаких ошибок, несмотря на неизвестные теги и устаревшую версию. Просто работает, прощает ошибки.

Браузер разбирается, где заголовок страницы легко:  
  
&lt;HEADER&gt;  
&lt;TITLE&gt;The World Wide Web project&lt;/TITLE&gt;  
&lt;NEXTID N="55"&gt;  
&lt;/HEADER&gt;

Та же история с &lt;picture&gt;, он фолбечится на &lt;img&gt;, так что если браузер не понимает — всё равно будет картинка.

Так же работает &lt;noscript&gt; — нет JS, значит нет &lt;noscript&gt;, значит содержимое просто отображается.

Раньше был трюк:  
  
&lt;script&gt;&lt;!--  
// --&gt;&lt;/script&gt;  
  
Чтобы содержимое точно не отобразилось.

Как устроена магия [pic.twitter.com/8llrpl7MXQ](https://t.co/8llrpl7MXQ)

![](https://pbs.twimg.com/media/ClEi8g1WEAAzP_r.jpg)

Как же работает токенайзер? Нильс разбирает парсинг &lt;a href="\#"&gt; побуквенно.

Всё гораздо сложнее чем кажется, но главное, что если происходит ошибка, парсер не останавливается.

Это всё нормальные теги [pic.twitter.com/Bu8H3TCFMQ](https://t.co/Bu8H3TCFMQ)

![](https://pbs.twimg.com/media/ClEj9VXWQAAqexE.jpg)

![](https://pbs.twimg.com/media/ClEj-E8WAAEobwF.jpg)

Если там не пробел, то нет атрибута, очень злая шутка [pic.twitter.com/ktt4PnRXaN](https://t.co/ktt4PnRXaN)

![](https://pbs.twimg.com/media/ClEkRK4XIAAPYPt.jpg)

Тег должен начинаться с a-z, а дальше может идти что угодно, хоть эмодзи.

То есть можно писать любой тег и всё будет в порядке, если только в будущем не появится такой тег. Для этого есть кастомные элементы.

Пробелы в имени не разрешены, но в спецификации HTML есть момент: там обещано, что не будет никаких дефисов, а значит &lt;my-element&gt; вполне.

[pic.twitter.com/bzlr9om9rp](https://t.co/bzlr9om9rp)

![](https://pbs.twimg.com/media/ClElIHfWMAAsTUT.jpg)

Если сделать innerHTML = '&lt;image&gt;', то tagName будет всё равно IMG, специальный случай в токенайзере.

Если весь документ состоит просто из &lt;a href="\#"&gt;👍&lt;/a&gt;, браузер создаст всё, чего не хватает

[pic.twitter.com/fbyIsBnPih](https://t.co/fbyIsBnPih)

![](https://pbs.twimg.com/media/ClEmLZVWAAANFgD.jpg)

Из-за этого механизма нельзя добавлять новые элементы в &lt;head&gt;, приходится придумывать вариации &lt;meta&gt; и &lt;link&gt;

[pic.twitter.com/HdsIBph4Gg](https://t.co/HdsIBph4Gg)

![](https://pbs.twimg.com/media/ClEmelMWMAELR8p.jpg)

Вам тоже страшно?

Сложная система разбора незакрытых тегов [pic.twitter.com/NffSWXjOxb](https://t.co/NffSWXjOxb)

![](https://pbs.twimg.com/media/ClEnJNIWAAAFg29.jpg)

Токенайзер помещается на 300 страниц A4. Тяжёлое чтиво, но учит многому.

Первый HTML невалидный! Там есть лишний закрывающий &lt;/a&gt;, но в этом его красота. В этом его доступность и открытость в будущее.

Поэтому грустно смотреть на такие страницы, это AMP [pic.twitter.com/WU8O1zJ1kp](https://t.co/WU8O1zJ1kp)

![](https://pbs.twimg.com/media/ClEoT8rWIAAzOMV.jpg)

Слишком много белых страниц при отключенном JS. Разработчики отказывают HTML в его готовности к ошибкам.

— Так можно ли вложить &lt;noscript&gt; в &lt;noscript&gt;?  
— В общем, нет \(показывает на токенайзере\)

— Можно ли отобразить &lt;noscript&gt; с помощью стилей?  
— Не-а.

— Можно ли вложить &lt;script&gt; в &lt;noscript&gt;?  
— Это просто глупо.

20 вопросов от Нильса по токенайзеру: отвечайте, делитесь в Твиттере — [html5te.st/quiz/](https://t.co/U4rNGKQqdX "http://html5te.st/quiz/")

Шестой доклад на HTML Special: Моника Динкулеску про элемент &lt;input&gt;. Работает в Google над Polymer.

Статья Моники &lt;input&gt; I love you but you’re bringing me down — по мотивам песни LCD Soundsystem про New York.

Моника работала над полями ввода для Polymer, наслушалась багов по ним, начиталась спецификаций и вот, докладывает.

1993 — HTML, один браузер  
1995 — HTML2, три браузера… и появился &lt;input&gt;! И 8 типов к нему: text, password и другие базовые, вкл. file.

Мало кто знает \(помнит\), но &lt;input type=image&gt; кажется бесполезным, но отравляет координаты клика по картинке.

Самый нелюбимый элемент разработчиков — не оформить, не локализовать, ужас. [pic.twitter.com/QZz66E1xOS](https://t.co/QZz66E1xOS)

![](https://pbs.twimg.com/media/ClEr3cYWMAIKn4L.jpg)

1995—1999 — ничего нового  
1999 — HTML4, &lt;button&gt; и &lt;input type=button&gt; как что-то вроде фолбека.

Спустя 21 год после появления &lt;input type=file&gt; мы всё ещё пишем хаки и кликаем по кнопкам-обманкам, чтобы выбрать файл.

WHY NOT [pic.twitter.com/7VTvRDfshn](https://t.co/7VTvRDfshn)

![](https://pbs.twimg.com/media/ClEs4VnWYAEdlVT.jpg)

![](https://pbs.twimg.com/media/ClEs5cHWIAEfhLs.jpg)

![](https://pbs.twimg.com/media/ClEs6S9WYAA91Uw.jpg)

2011 — HTML5, появилось куча типов &lt;input&gt;, но большинство из них 5 лет спустя так и не реализованы.

Давайте оформим &lt;input type=range&gt;… [pic.twitter.com/5d2l7AkX7P](https://t.co/5d2l7AkX7P)

![](https://pbs.twimg.com/media/ClEtiFWWgAAV7YP.jpg)

&lt;input type=number&gt;  
  
1234 = 1234  
'' = ''  
sd\_3434 = ''  
  
То есть уверенно не сказать — там пусто или там число.

В &lt;input type=number&gt; почему-то нельзя получить выделение, как в type=text.

Решение?  
  
&lt;type-number&gt;  
&lt;color-picker&gt;  
  
Кастомные элементы.

2012 — Веб-компоненты, новая надежда, без проблем с обратной совместимостью.

Как устроен &lt;input type=number&gt; [pic.twitter.com/9W7yOWVQj0](https://t.co/9W7yOWVQj0)

![](https://pbs.twimg.com/media/ClEvSzUWMAAxqqo.jpg)

Как же сделать свои инпуты? Что нужно:  
1. Shadow DOM  
2. document.registerElement  
3. HTML-импорт

Пишем свой инпут [pic.twitter.com/yNk5d8mDfM](https://t.co/yNk5d8mDfM)

![](https://pbs.twimg.com/media/ClEwApZWIAAFOaw.jpg)

Можно ведь не писать всё самим, а использовать поведение существующих элементов [pic.twitter.com/9Vf87qkmcb](https://t.co/9Vf87qkmcb)

![](https://pbs.twimg.com/media/ClEwcesXIAA_UKJ.jpg)

В 2016 году мы знаем что такое полифил, мы можем развивать платформу не создавая множество мёртвых частей, как в 90-х.

Вопросы [pic.twitter.com/S1oh1igxmn](https://t.co/S1oh1igxmn)

![](https://pbs.twimg.com/media/ClExMzuXEAAKv6L.jpg)

— Почему всё так плохо с инпутами?  
— У нас есть багаж кода, написанного за 21 год и он должен работать

У нас перерыв до 16:45 по Москве, следующий доклад про &lt;iframe&gt;

Седьмой доклад на HTML Special: Питер Ван Дер Зи про элемент &lt;iframe&gt;.

Инлайновый фрейм или плавающий фрейм? Скотт Айзакс из Microsoft, который изобрёл его, говорит, что это всё-таки инлайновый фрейм, i-frame.

У &lt;iframe&gt; 15 атрибутов, самый бесполезный — align, конечно же.

Но Питер не поленился потестировать работу атрибута align, просто чтобы [pic.twitter.com/WwMxqunhBw](https://t.co/WwMxqunhBw)

![](https://pbs.twimg.com/media/ClE7ZsCWQAAVhRP.jpg)

Атрибут allowfullscreen — уже полезнее, защищает от сторонних страниц, которые могут без спроса занять весь экран.

Атрибут border не делает ничего, зато зачем-то есть frameborder. И даже здесь браузеры ведут себя по-разному &gt;\_\_&lt;

Не используйте frameborder!

Интересный факт width="50em" и width="50px" будут одинаковой ширины, они все приводятся к width="50". Не используйте атрибуты width и height

Атрибут longdesc конвертирует относительные пути в абсолютные… не используйте его.

Думаете, что marginwidth=10 и marginheight=10 выставит iframe { margin: 0 10px }? Ха! Нет, это особые внутренние отступы. Не используйте их.

Атрибут name позволяет обращаться к ифрейму через target=name, на манер знакомых \_blank, \_parent, \_self, \_top… Связка name + target сложная.

Тест! Так себе [pic.twitter.com/mk7NJcYv7P](https://t.co/mk7NJcYv7P)

![](https://pbs.twimg.com/media/ClE9bbFWEAARdst.jpg)

XHTML запретил name и заменил на id и нужно указывать оба для обратной совместимости, если очень нужно.

Полезный атрибут referer поддерживается слабо и по-разному [caniuse.com/\#feat=referrer…](https://t.co/JIYZYDtAgP "http://caniuse.com/#feat=referrer-policy")

Атрибут scrolling = yes | no | auto, это способ контролировать прокрутку документа снаружи, но… не используйте его.

Атрибут sandbox со значениями allow- …forms | modals | popups | … — все они выключены по умолчанию, но можно разрешить нужное.

Атрибут sandbox поддерживается хорошо, но далеко не все значения [caniuse.com/\#search=sandbox](https://t.co/G48jktv4pN "http://caniuse.com/#search=sandbox")

Атрибут seamless должен был сделать &lt;iframe&gt; частью документа, даже начали внедрять, но уже удаляют из спецификации. Не используйте.

В атрибуте src можно исполнить JS и строка в результате станет содержимым фрейма.

Если вернуть не строку, то ничего не отрендерится [pic.twitter.com/pT6IikOyss](https://t.co/pT6IikOyss)

![](https://pbs.twimg.com/media/ClFBQeNWQAAIwZW.jpg)

Свою дотошность Питер пускает в дело, он автор конкурса [js1k.com](https://t.co/5nlBfVGxEI "http://js1k.com/")

В IE нельзя делать dataURI в &lt;iframe src&gt;, вообще нельзя. Для безопасности.

Специальные домены в src [pic.twitter.com/xGFzVeoLEh](https://t.co/xGFzVeoLEh)

![](https://pbs.twimg.com/media/ClFCApzWgAA28p4.jpg)

Атрибут srcdoc="foo" даёт что-то вроде src="javascript:'foo'", фолбечится на src, пока не поддерживается в Edge, но будет.

API для навигации между фреймами не очень понятно называется, но вполне кроссбраузерный [pic.twitter.com/rkHkfW0QQ0](https://t.co/rkHkfW0QQ0)

![](https://pbs.twimg.com/media/ClFC4IGWkAER72o.jpg)

Восьмой и последний доклад на HTML Special: Лия Веру про элемент &lt;html&gt;. Докладчик, исследователь в MIT, автор книги «CSS-секреты».

Географически Лия лесбиянка, в смысле, с острова Лесбос в Греции [pic.twitter.com/B0JhH6p17n](https://t.co/B0JhH6p17n)

![](https://pbs.twimg.com/media/ClFFPJOWQAEjO8F.jpg)

HTML-секреты! Раз уж есть книга про CSS-секреты

Не будем говорить:  
— про семантику \(отдельная история\)  
— про поддержку браузеров \(вечнозелёные и всё полифилится\)

Как найти полифил? Поиск по Гитхабу: details + polyfill и отсортировать по звёздам.

Начнём: &lt;a download&gt;, очень удобная штука, чтобы, скажем, не открывать plain/text или картинки, а скачивать их, если такая задача.

В атрибуте download можно указывать имя файла! Если, скажем, содержимое сгенерировано в dataURI.

&lt;input type=file accept="image/png"&gt; отфильтрует в диалоге выбора только PNG. Теперь можно "image/\*" и даже ".png, .gif".

Можно выбирать несколько файлов: &lt;input type=file multiple&gt;, с хорошей браузерной поддержкой.

Малоизвестный элемент &lt;dialog&gt;, решение проблемы модальности по спецификации, без велосипедов.

[pic.twitter.com/M6FFeYMut5](https://t.co/M6FFeYMut5)

![](https://pbs.twimg.com/media/ClFIEOTWEAEsAa6.jpg)

Браузер реализует модальность и горячие клавиши за вас! И даже фоновое затенение [pic.twitter.com/4fZev59XaB](https://t.co/4fZev59XaB)

![](https://pbs.twimg.com/media/ClFIQ2-WkAEDohC.jpg)

Внимание, это просто демки! [pic.twitter.com/k2TNamr6xo](https://t.co/k2TNamr6xo)

![](https://pbs.twimg.com/media/ClFIfv6WgAA16xn.jpg)

&lt;form method="dialog"&gt; \(вместо get и post\) работает в связке с &lt;dialog&gt;.

Когда диалог закрылся, он отправляет событие, которое заполняет эту форму. Точнее, браузер за вас.

В srcdoc можно не писать вступление про dataURI, а сразу HTML [pic.twitter.com/upMkLSzu1T](https://t.co/upMkLSzu1T)

![](https://pbs.twimg.com/media/ClFJjqGWQAAgit1.jpg)

Атрибут srcdoc полифилится за 4 строки через src + dataURI.

Атрибут scrdoc ввели для безопасности и работы в связке с sandbox.

Чтобы показать alert\(\) из srcdoc + sandbox нужно два разрешения на скрипты и модальные окна [pic.twitter.com/T9sfJgwkAx](https://t.co/T9sfJgwkAx)

![](https://pbs.twimg.com/media/ClFKRhYWgAA9Wx7.jpg)

Уже говорили сегодня про &lt;input type=range&gt;, крутая штука из HTML5.

Слайдеры очень сложно оформить, но можно! И нужно, коллекция Аны Тюдор [pic.twitter.com/DnlWTZe1qD](https://t.co/DnlWTZe1qD)

![](https://pbs.twimg.com/media/ClFKw6fWEAUby3x.jpg)

Слайдеры &lt;input type=range&gt; поддерживают атрибут multiple, чтобы можно было выбрать диапазон двумя ручкам.

Но Лия написала полифил [pic.twitter.com/TfGs1yyCPh](https://t.co/TfGs1yyCPh)

![](https://pbs.twimg.com/media/ClFLS72WgAANG6J.jpg)

&lt;input&gt; показывает подсказки в последнем обновлении Chrome, если только завернуть его в &lt;form&gt;

Атрибут autocomplete="email" может подсказать то, что нужно подсказывать в конкретном случае. Длинный список вариантов, включая cc-number.

Карточные автозаполнения работают только на HTTPS.

Подробнее про автозаполнение в самой большой статье об этом: [blog.cloudfour.com/autofill-what-…](https://t.co/bAC1bgf2bi "http://blog.cloudfour.com/autofill-what-web-devs-should-know-but-dont/")

Подсказки можно генерировать самостоятельно с помощью &lt;datalist&gt;

[pic.twitter.com/IJFTEGYoso](https://t.co/IJFTEGYoso)

![](https://pbs.twimg.com/media/ClFNBr8XIAAVD4L.jpg)

Элемент &lt;datalist&gt; + &lt;input type=range&gt; создаёт насечки на диапазоне, к которым прилипает ручка. По идее, даже подписи можно делать, но нет.

&lt;input type="color"&gt; принимает только 6-значные HEX-значения, никаких 3-значных или HSL. Но сюда тоже можно прицепить &lt;datalist&gt;!

[pic.twitter.com/kLrwhApNia](https://t.co/kLrwhApNia)

![](https://pbs.twimg.com/media/ClFNqZyWEAA0Uby.jpg)

Элементы &lt;details&gt; + &lt;summary&gt; — показывать и скрывать что-нибудь доступно и удобно.

Атрибуты details меняются прямо в HTML, не только в виде JS-свойства [pic.twitter.com/JAqlaDBAyI](https://t.co/JAqlaDBAyI)

![](https://pbs.twimg.com/media/ClFOCx3WMAAsoTs.jpg)

Есть спецсобытие toggle, легко можно сделать аккордеон [pic.twitter.com/tJODbhkn1k](https://t.co/tJODbhkn1k)

![](https://pbs.twimg.com/media/ClFOgfvWIAEWgGi.jpg)

Маркер &lt;details&gt; можно оформить, но сложновато. Скоро стандартизируют с псевдоэлементом ::marker.

Кроме известного maxlenght есть ещё minlength, иначе поле невалидное и это можно поймать с псевдоклассами :valid или :invalid.

Странно, но minlength=1 работает идентично атрибуту required. И не странно, если подумать.

&lt;input pattern=\[a-z\]&gt; фильтрует вводимые символы, библиотека паттернов для частых случаев [html5pattern.com](https://t.co/ibmgd6qhxG "http://html5pattern.com/")

Тестер регулярных выражений в двух строках: генерируем паттерн динамически! [pic.twitter.com/8aLIYeabOJ](https://t.co/8aLIYeabOJ)

![](https://pbs.twimg.com/media/ClFQAu-WIAEvHXp.jpg)

Полифилим атрибут pattern для &lt;textarea&gt; прямо на сцене, т.к. его похоже не будет в спеке [pic.twitter.com/tTWiQrhdHT](https://t.co/tTWiQrhdHT)

![](https://pbs.twimg.com/media/ClFQ9lcWMAERXCP.jpg)

Можно ещё определять размер загружаемых файлов, прежде чем отправлять их [pic.twitter.com/WXTTYnUHSe](https://t.co/WXTTYnUHSe)

![](https://pbs.twimg.com/media/ClFRVCWXEAA5EaD.jpg)

Помогаем поисковикам показывать полезные снипеты с микроданными [pic.twitter.com/FXSM8BugFU](https://t.co/FXSM8BugFU)

![](https://pbs.twimg.com/media/ClFRu1EWQAAoqqF.jpg)

Копать дальше: [schema.org](https://t.co/D1rI1hgFDg "http://schema.org/")

Всё делится на две части: словарь [Schema.org](https://t.co/WSeAYkzZOQ "http://Schema.org") \(OpenGraph, Microformats\) и формат: Microdata \(RDFa, …\)

[pic.twitter.com/cmpk7bepRk](https://t.co/cmpk7bepRk)

![](https://pbs.twimg.com/media/ClFSZ8JWgAAmhx0.jpg)

Но Гугл предпочитает JSON-LD, Лия удивляется почему кому-то нужно дублировать информацию [pic.twitter.com/Cb4lc0RWGC](https://t.co/Cb4lc0RWGC)

![](https://pbs.twimg.com/media/ClFS8jRWkAA1WHM.jpg)

И то же самое на Микроформатах [pic.twitter.com/zatAVPtbWo](https://t.co/zatAVPtbWo)

![](https://pbs.twimg.com/media/ClFTFKxXEAQfrI9.jpg)

То же на OpenGraph [pic.twitter.com/AeBAOmNxj8](https://t.co/AeBAOmNxj8)

![](https://pbs.twimg.com/media/ClFTL0NXEAAo2fa.jpg)

&lt;link&gt; и &lt;meta&gt; могут находится где угодно, если есть атрибуты itemprop или property, согласно HTML5. Если валидатор против — он устарел.

[pic.twitter.com/EShkIB6ZIH](https://t.co/EShkIB6ZIH)

![](https://pbs.twimg.com/media/ClFT1PwXEAEeFea.jpg)

Почему же у нас два источника правды и две спеки? Очень длинная и сложная история [pic.twitter.com/iKnPzOeKiG](https://t.co/iKnPzOeKiG)

![](https://pbs.twimg.com/media/ClFUQpOXIAA6Ist.jpg)

Версия WHATWG живая, можно сослаться и потерять место. Но её удобно читать, там точно актуальная информация, без бюрократии.

Версия W3C имеет канонические снимки, ссылки не ломаются, есть чёткий процесс, но всё медленнее.

Вопросы [pic.twitter.com/QDVYYTwgxi](https://t.co/QDVYYTwgxi)

![](https://pbs.twimg.com/media/ClFUuWqWIAQk45A.jpg)

Как определить спецификацию? За версиями W3C стоит юр. организация. За WHATWG никто, кроме группы людей, которые договорились. Всё спеки.

— Как с поддержкой &lt;dialog&gt;?  
— 50% пользователей, но всё отлично полифилится, это же HTML, даже Гудини не нужен.  
  
[caniuse.com/\#feat=dialog](https://t.co/dIi626iGUe "http://caniuse.com/#feat=dialog")

День HTML Special подошёл к концу, может быть повторят в следующем году. А то и расширят в сторну &lt;svg&gt; или дизайна.

Спасибо, что читали. С вами был [@pepelsbey](https://twitter.com/pepelsbey "Вадим Макеев"), увидимся завтра утром на CSS Day, программа [cssday.nl/2016/programme…](https://t.co/eGgXpMUP94 "http://cssday.nl/2016/programme#day2"), начнём в 10:00 по Москве.
